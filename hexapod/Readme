"""
RPI
Current WiFi & Password: WJ | 88888888 
username: spider 
Password: Spider@01
IP: xxx.xx.xx.34 (usually but might not always 34), first three numbers can be obtained from checking Ip numbers of the WiFi
* ssh into the pi with ssh spider@<IP_ADDRESS>
* To get exact Ip, either login to the rpi and call "hostname -I" or call "FOR /L %i IN (1,1,254) DO ping -n 1 192.168.1.%i | FIND /i "Reply" >> ip_list.txt" in desktop terminal by replacing 192.168.1 with actual WiFi Ip (assuming both desktop and RPI are connected to the same network), then find ip_list.txt file to get the exact Ip.

Running Robot
1. Source ros, hexapod_ros and hexapod_msgs, can be call at one with "hexapod_env".
2. Open two terminals, call "ros2 launch hexapod_ros hexapod.launch.py" and "ros2 run hexapod_ros teleop" in each terminal. 
3. Control the robot from teleop terminal, with keys:
- q : move front left
- w : move forward
- e : move front right
- a : move left
- s : move backward
- d : move right
- z : move back left
- x : move back right
- o : turn clockwise
- p : turn counter clockwise
- space : stop
- ctrl+c : terminate process
* Commands are in queue hence can has duplicate or multiple commands, pressing stop will force the robot to stop immediately.
4. Ctrl+c on both terminals to kill the process. 
* The robot will fall after the kill as there is no sit function. Handle with care.

Monitoring
1. Make sure to work in ubuntu desktop with ros tools installed.
2. Source ros.
3. Call ros2 run rqt_plot /pitch_angle/data 
* There is only pitch_angle / pitch_error / roll_angle / roll_error data for monitoring right now, angle is the reading from gyrosensor while error is the feedback from PID controller to the robot.

Configuration
A. PID
1. Locate to hexapod_ros/install/hexapod_ros/share/hexapod_ros/config to open pid_params.yaml. 
2. dt is the IMU refresh rate, if changed need to change the timer in imu_node as well. In addition, need to change the baud rate of maestro driver in maestro file and board itself. 
3. If the robot has to recalibrate, change the calibrated value to 0, the robot will calibrate the bias on the next start up time and update back.
4. Adjust pid gain if needed:
- filter_coe : fusion ratio for accumulated gyro value to calculated acceleration value, 0.9~0.95 is fine
- kd : differential component, help to introduce damping into controller, cannot be too big since the refresh rate is very fast.
- ki : integal component, help to prevent steady state error, not using a lot right now.
- kp : propotional component, gain to correct the angle.
- max_I : max sum error, sum error correspond to integral component. 
- max_angle : bound of max error angle. 
5. Update to the values to pid_params.yaml in /src/config if any changes are going to be made in the original file
* Changing params requires restarting the launch script, but no colcon build is needed unless modifying source code.

B. Parameter
1. All other config value is under this parameter.py file.
2. Changing these values requires a full colcon build.

Future Work
A. Mechanical 
1. Current servos have ±1–2° backlash, causing IK inaccuracy. This errors can not be capture as there is no encoder in the motor, it only allows forward control. In addition, L1 motor is overheated during run. 
2. Base is not constrained, it can bend causing the leg to drop out when taking load. Although this issue is fixed with cable tie currently, design change is needed for next iteration.
3. Nuts loosen due to vibration. Can solve with double nuts or thread-locker.

B. Electrical
1. Cable management improvement for the contact sensor.
2. Might need to switch battery as current batteries have been down to 5-6.5V multiple times.
3. Upgrade 6-DOF IMU to 9-DOF for yaw control
4. Add camera or LiDAR for environmental perception.
5. Build or integrate a joystick-based controller.

C. Algorithm
1. Further PID tuning for optimal stability.
2. Tune walking speed and stop timing for smoother gait.
3. Currently the robot only walk in trigait, can add other gait in parameter.py to the robot.
4. Make walking or turning distance adjustable during teleop.
5. Integrate contact feedback so the robot knows when legs touch the ground.
6. Implement velocity-based control (currently IK position-based only).
7. Develop dynamics model or reinforcement learning for improved stability and gait optimization.
* 5 & 6 need motor with encoder. 

"""

testing



